//! Build script for resin-audio.
//!
//! Generates optimized effect structs for benchmarking Tier 4 codegen.

fn main() {
    #[cfg(feature = "codegen-bench")]
    generate_benchmark_effects();
}

#[cfg(feature = "codegen-bench")]
fn generate_benchmark_effects() {
    use std::env;
    use std::fs;
    use std::path::Path;

    // We can't use the codegen module directly in build.rs because it's part of the crate
    // being built. Instead, we inline the SerialAudioGraph types and generate code here.

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("codegen_bench.rs");

    // Generate tremolo effect using the same structure as SerialAudioGraph
    // This demonstrates the codegen approach without circular dependencies
    let code = r#"
// Generated by build.rs for benchmarking Tier 4 codegen
// This uses the same optimizations as the codegen module

use rhizome_resin_audio::graph::{AudioContext, AudioNode};

/// Tremolo effect generated at build time.
///
/// Equivalent to SerialAudioGraph with:
/// - nodes: [Lfo { rate: 5.0 }, Gain { gain: 1.0 }]
/// - param_wires: [{ from: 0, to: 1, base: 0.5, scale: 0.5 }]
pub struct GeneratedTremolo {
    // Node 0: LFO
    node_0: rhizome_resin_audio::primitive::PhaseOsc,
    node_0_phase_inc: f32,
    // Node 1: Gain (optimized away - just use the modulation directly)
    // Pre-computed modulation constants
    mod_0_base: f32,
    mod_0_scale: f32,
}

impl GeneratedTremolo {
    pub fn new(sample_rate: f32) -> Self {
        Self {
            node_0: rhizome_resin_audio::primitive::PhaseOsc::new(),
            node_0_phase_inc: 5.0_f32 / sample_rate,
            mod_0_base: 0.5_f32,
            mod_0_scale: 0.5_f32,
        }
    }
}

impl AudioNode for GeneratedTremolo {
    #[inline]
    fn process(&mut self, input: f32, _ctx: &AudioContext) -> f32 {
        // Optimized tremolo processing
        let lfo_out = self.node_0.sine();
        self.node_0.advance(self.node_0_phase_inc);
        let gain = self.mod_0_base + lfo_out * self.mod_0_scale;
        input * gain
    }

    fn reset(&mut self) {
        self.node_0.reset();
    }
}

/// Chorus effect generated at build time.
///
/// Matches ChorusOptimized algorithm: LFO modulates delay time, mixed with dry.
pub struct GeneratedChorus {
    lfo: rhizome_resin_audio::primitive::PhaseOsc,
    delay: rhizome_resin_audio::primitive::DelayLine<true>,
    phase_inc: f32,
    base_delay: f32,
    depth: f32,
    mix: f32,
}

impl GeneratedChorus {
    pub fn new(sample_rate: f32) -> Self {
        // Match ChorusOptimized parameters: rate=0.5, base=7ms, depth=3ms, mix=0.5
        let base_delay = 7.0 * sample_rate / 1000.0;
        let depth = 3.0 * sample_rate / 1000.0;
        let max_delay = ((7.0 + 3.0 * 2.0) * sample_rate / 1000.0) as usize + 1;

        Self {
            lfo: rhizome_resin_audio::primitive::PhaseOsc::new(),
            delay: rhizome_resin_audio::primitive::DelayLine::new(max_delay),
            phase_inc: 0.5_f32 / sample_rate,
            base_delay,
            depth,
            mix: 0.5_f32,
        }
    }
}

impl AudioNode for GeneratedChorus {
    #[inline]
    fn process(&mut self, input: f32, _ctx: &AudioContext) -> f32 {
        let lfo_out = self.lfo.sine();
        self.lfo.advance(self.phase_inc);

        let delay_time = self.base_delay + lfo_out * self.depth;
        self.delay.write(input);
        let wet = self.delay.read_interp(delay_time);

        // Mix dry and wet
        input * (1.0 - self.mix) + wet * self.mix
    }

    fn reset(&mut self) {
        self.lfo.reset();
        self.delay.clear();
    }
}

/// Flanger effect generated at build time.
///
/// Matches ModulatedDelay/flanger() behavior: LFO modulates delay time with feedback and mix.
pub struct GeneratedFlanger {
    lfo: rhizome_resin_audio::primitive::PhaseOsc,
    delay: rhizome_resin_audio::primitive::DelayLine<true>,
    phase_inc: f32,
    base_delay: f32,
    depth: f32,
    feedback: f32,
    mix: f32,
}

impl GeneratedFlanger {
    pub fn new(sample_rate: f32) -> Self {
        // Match original flanger(): rate=0.3, base=3ms, depth=2ms, feedback=0.7, mix=0.5
        let base_delay = 3.0 * sample_rate / 1000.0;
        let depth = 2.0 * sample_rate / 1000.0;
        let max_delay = ((3.0 + 2.0 * 2.0) * sample_rate / 1000.0) as usize + 1;

        Self {
            lfo: rhizome_resin_audio::primitive::PhaseOsc::new(),
            delay: rhizome_resin_audio::primitive::DelayLine::new(max_delay),
            phase_inc: 0.3_f32 / sample_rate,
            base_delay,
            depth,
            feedback: 0.7_f32,
            mix: 0.5_f32,
        }
    }
}

impl AudioNode for GeneratedFlanger {
    #[inline]
    fn process(&mut self, input: f32, _ctx: &AudioContext) -> f32 {
        let lfo_out = self.lfo.sine();
        self.lfo.advance(self.phase_inc);

        let delay_time = self.base_delay + lfo_out * self.depth;
        let delayed = self.delay.read_interp(delay_time);

        // Write with feedback
        self.delay.write(input + delayed * self.feedback);

        // Mix dry and wet
        input * (1.0 - self.mix) + delayed * self.mix
    }

    fn reset(&mut self) {
        self.lfo.reset();
        self.delay.clear();
    }
}
"#;

    fs::write(&dest_path, code).unwrap();
    println!("cargo:rerun-if-changed=build.rs");
}
