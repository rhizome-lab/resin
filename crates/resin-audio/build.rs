//! Build script for resin-audio.
//!
//! Generates optimized effect structs for benchmarking Tier 4 codegen.

fn main() {
    #[cfg(feature = "codegen-bench")]
    generate_benchmark_effects();
}

#[cfg(feature = "codegen-bench")]
fn generate_benchmark_effects() {
    use std::env;
    use std::fs;
    use std::path::Path;

    // We can't use the codegen module directly in build.rs because it's part of the crate
    // being built. Instead, we inline the SerialAudioGraph types and generate code here.

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("codegen_bench.rs");

    // Generate tremolo effect using the same structure as SerialAudioGraph
    // This demonstrates the codegen approach without circular dependencies
    let code = r#"
// Generated by build.rs for benchmarking Tier 4 codegen
// This uses the same optimizations as the codegen module

use rhizome_resin_audio::graph::{AudioContext, AudioNode};

/// Tremolo effect generated at build time.
///
/// Equivalent to SerialAudioGraph with:
/// - nodes: [Lfo { rate: 5.0 }, Gain { gain: 1.0 }]
/// - param_wires: [{ from: 0, to: 1, base: 0.5, scale: 0.5 }]
pub struct GeneratedTremolo {
    // Node 0: LFO
    node_0: rhizome_resin_audio::primitive::PhaseOsc,
    node_0_phase_inc: f32,
    // Node 1: Gain (optimized away - just use the modulation directly)
    // Pre-computed modulation constants
    mod_0_base: f32,
    mod_0_scale: f32,
}

impl GeneratedTremolo {
    pub fn new(sample_rate: f32) -> Self {
        Self {
            node_0: rhizome_resin_audio::primitive::PhaseOsc::new(),
            node_0_phase_inc: 5.0_f32 / sample_rate,
            mod_0_base: 0.5_f32,
            mod_0_scale: 0.5_f32,
        }
    }
}

impl AudioNode for GeneratedTremolo {
    #[inline]
    fn process(&mut self, input: f32, _ctx: &AudioContext) -> f32 {
        // Optimized tremolo processing
        let lfo_out = self.node_0.sine();
        self.node_0.advance(self.node_0_phase_inc);
        let gain = self.mod_0_base + lfo_out * self.mod_0_scale;
        input * gain
    }

    fn reset(&mut self) {
        self.node_0.reset();
    }
}

/// Chorus effect generated at build time.
///
/// Equivalent to SerialAudioGraph with:
/// - nodes: [Lfo { rate: 0.5 }, Delay { max_samples: 4096 }, Mix { mix: 0.5 }]
/// - param_wires: [{ from: 0, to: 1, base: 882.0, scale: 220.0 }]
pub struct GeneratedChorus {
    // Node 0: LFO
    node_0: rhizome_resin_audio::primitive::PhaseOsc,
    node_0_phase_inc: f32,
    // Node 1: Delay
    node_1: rhizome_resin_audio::primitive::DelayLine<true>,
    // Node 2: Mix (just a constant)
    node_2: f32,
    // Pre-computed modulation constants
    mod_0_base: f32,
    mod_0_scale: f32,
}

impl GeneratedChorus {
    pub fn new(sample_rate: f32) -> Self {
        Self {
            node_0: rhizome_resin_audio::primitive::PhaseOsc::new(),
            node_0_phase_inc: 0.5_f32 / sample_rate,
            node_1: rhizome_resin_audio::primitive::DelayLine::new(4096),
            node_2: 0.5_f32,
            // Base delay ~20ms, depth ~5ms at 44.1kHz
            mod_0_base: 0.020_f32 * sample_rate,
            mod_0_scale: 0.005_f32 * sample_rate,
        }
    }
}

impl AudioNode for GeneratedChorus {
    #[inline]
    fn process(&mut self, input: f32, _ctx: &AudioContext) -> f32 {
        // Optimized chorus processing
        let lfo_out = self.node_0.sine();
        self.node_0.advance(self.node_0_phase_inc);
        let delay_time = self.mod_0_base + lfo_out * self.mod_0_scale;
        let delayed = self.node_1.read_interp(delay_time);
        self.node_1.write(input);
        input * (1.0 - self.node_2) + delayed * self.node_2
    }

    fn reset(&mut self) {
        self.node_0.reset();
        self.node_1.clear();
    }
}

/// Flanger effect generated at build time.
///
/// Similar to chorus but with shorter delay and feedback.
pub struct GeneratedFlanger {
    node_0: rhizome_resin_audio::primitive::PhaseOsc,
    node_0_phase_inc: f32,
    node_1: rhizome_resin_audio::primitive::DelayLine<true>,
    feedback: f32,
    mod_0_base: f32,
    mod_0_scale: f32,
    last_output: f32,
}

impl GeneratedFlanger {
    pub fn new(sample_rate: f32) -> Self {
        Self {
            node_0: rhizome_resin_audio::primitive::PhaseOsc::new(),
            node_0_phase_inc: 0.25_f32 / sample_rate,
            node_1: rhizome_resin_audio::primitive::DelayLine::new(1024),
            feedback: 0.7_f32,
            // Base delay ~1ms, depth ~2ms
            mod_0_base: 0.001_f32 * sample_rate,
            mod_0_scale: 0.002_f32 * sample_rate,
            last_output: 0.0,
        }
    }
}

impl AudioNode for GeneratedFlanger {
    #[inline]
    fn process(&mut self, input: f32, _ctx: &AudioContext) -> f32 {
        let lfo_out = self.node_0.sine();
        self.node_0.advance(self.node_0_phase_inc);
        let delay_time = self.mod_0_base + lfo_out * self.mod_0_scale;
        let delayed = self.node_1.read_interp(delay_time);
        let output = input + delayed * self.feedback;
        self.node_1.write(input + self.last_output * self.feedback);
        self.last_output = delayed;
        output * 0.5 + input * 0.5
    }

    fn reset(&mut self) {
        self.node_0.reset();
        self.node_1.clear();
        self.last_output = 0.0;
    }
}
"#;

    fs::write(&dest_path, code).unwrap();
    println!("cargo:rerun-if-changed=build.rs");
}
