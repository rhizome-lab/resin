//! Build script for resin-audio.
//!
//! Generates optimized effect structs for benchmarking Tier 4 codegen.

fn main() {
    // Only generate benchmark effects when running benchmarks
    #[cfg(feature = "codegen-bench")]
    generate_benchmark_effects();
}

#[cfg(feature = "codegen-bench")]
fn generate_benchmark_effects() {
    use std::env;
    use std::fs;
    use std::path::Path;

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("codegen_bench.rs");

    // For now, generate a simple wrapper that demonstrates the approach.
    // A full implementation would analyze the graph and inline node processing.
    let code = r#"
// Generated by build.rs for benchmarking Tier 4 codegen

use rhizome_resin_audio::graph::{AudioContext, AudioNode};
use rhizome_resin_audio::primitive::{GainNode, LfoNode};

/// Tremolo effect generated at build time.
pub struct GeneratedTremolo {
    lfo: LfoNode,
    gain: GainNode,
    phase_inc: f32,
    base: f32,
    scale: f32,
}

impl GeneratedTremolo {
    pub fn new(sample_rate: f32) -> Self {
        Self {
            lfo: LfoNode::with_freq(5.0, sample_rate),
            gain: GainNode::new(1.0),
            phase_inc: 5.0 / sample_rate,
            base: 0.5,
            scale: 0.5,
        }
    }
}

impl AudioNode for GeneratedTremolo {
    fn process(&mut self, input: f32, ctx: &AudioContext) -> f32 {
        // Inlined processing - no trait dispatch
        let lfo_out = self.lfo.process(0.0, ctx);
        let gain_val = self.base + lfo_out * self.scale;
        self.gain.set_gain(gain_val);
        self.gain.process(input, ctx)
    }

    fn reset(&mut self) {
        self.lfo.reset();
        self.gain.reset();
    }
}
"#;

    fs::write(&dest_path, code).unwrap();
    println!("cargo:rerun-if-changed=build.rs");
}
