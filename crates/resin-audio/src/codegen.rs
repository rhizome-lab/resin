//! Code generation for static audio graphs.
//!
//! This module provides utilities to generate optimized Rust code from
//! [`AudioGraph`] instances at build time. Use this in your `build.rs`
//! to compile audio graphs into efficient static structs.
//!
//! # Usage
//!
//! In your `build.rs`:
//!
//! ```ignore
//! use rhizome_resin_audio::codegen::GraphCodegen;
//! use rhizome_resin_audio::graph::AudioGraph;
//! use rhizome_resin_audio::primitive::{LfoNode, GainNode};
//!
//! fn main() {
//!     let sample_rate = 44100.0;
//!
//!     // Build graph using normal Rust code
//!     let mut graph = AudioGraph::new();
//!     let lfo = graph.add(LfoNode::with_freq(5.0, sample_rate));
//!     let gain = graph.add(GainNode::new(1.0));
//!     graph.wire_audio(graph.input().unwrap(), gain);
//!     graph.wire_param(lfo, gain, 0, 0.5, 0.5);
//!     graph.set_output(gain);
//!
//!     // Generate optimized code
//!     let codegen = GraphCodegen::new(&graph, "StaticTremolo");
//!     let code = codegen.generate();
//!
//!     // Write to OUT_DIR
//!     let out_dir = std::env::var("OUT_DIR").unwrap();
//!     std::fs::write(
//!         std::path::Path::new(&out_dir).join("tremolo.rs"),
//!         code
//!     ).unwrap();
//! }
//! ```
//!
//! Then in your library:
//!
//! ```ignore
//! // Include the generated code
//! include!(concat!(env!("OUT_DIR"), "/tremolo.rs"));
//!
//! // Use it like any other AudioNode
//! let mut tremolo = StaticTremolo::new();
//! let output = tremolo.process(input, &ctx);
//! ```
//!
//! # What Gets Generated
//!
//! The codegen produces:
//! - A struct with fields for each node
//! - A `new()` constructor
//! - An `AudioNode` implementation with optimized `process()`
//!
//! The generated code eliminates dynamic dispatch and wire iteration,
//! giving performance comparable to hand-written effect structs.

use crate::graph::AudioGraph;

/// Code generator for audio graphs.
///
/// Analyzes an [`AudioGraph`] and generates optimized Rust code.
pub struct GraphCodegen<'a> {
    graph: &'a AudioGraph,
    struct_name: &'a str,
}

impl<'a> GraphCodegen<'a> {
    /// Creates a new code generator.
    ///
    /// # Arguments
    ///
    /// * `graph` - The audio graph to generate code for
    /// * `struct_name` - Name for the generated struct (e.g., "StaticTremolo")
    pub fn new(graph: &'a AudioGraph, struct_name: &'a str) -> Self {
        Self { graph, struct_name }
    }

    /// Generates the Rust code for the optimized graph.
    ///
    /// Returns a string containing valid Rust code that can be written
    /// to a file and included with `include!()`.
    pub fn generate(&self) -> String {
        let mut code = String::new();

        // Header comment
        code.push_str(&format!(
            "// Generated by rhizome-resin-audio codegen\n\
             // Do not edit manually\n\n"
        ));

        // Use statements
        code.push_str("use rhizome_resin_audio::graph::{AudioContext, AudioNode};\n\n");

        // Generate struct
        code.push_str(&self.generate_struct());
        code.push('\n');

        // Generate impl
        code.push_str(&self.generate_impl());
        code.push('\n');

        // Generate AudioNode impl
        code.push_str(&self.generate_audio_node_impl());

        code
    }

    fn generate_struct(&self) -> String {
        let mut code = format!("pub struct {} {{\n", self.struct_name);

        // Add fields for each node
        // For now, we store node indices and process through the graph
        // A more advanced version would analyze node types and inline them
        code.push_str("    graph: rhizome_resin_audio::graph::AudioGraph,\n");

        code.push_str("}\n");
        code
    }

    fn generate_impl(&self) -> String {
        let mut code = format!("impl {} {{\n", self.struct_name);

        // Constructor - would need to serialize/deserialize the graph
        // For now, provide a from_graph constructor
        code.push_str("    /// Creates a new instance from a pre-built graph.\n");
        code.push_str(
            "    pub fn from_graph(graph: rhizome_resin_audio::graph::AudioGraph) -> Self {\n",
        );
        code.push_str("        Self { graph }\n");
        code.push_str("    }\n");

        code.push_str("}\n");
        code
    }

    fn generate_audio_node_impl(&self) -> String {
        let mut code = format!("impl AudioNode for {} {{\n", self.struct_name);

        // process() - delegate to graph for now
        // A more advanced version would inline the processing
        code.push_str("    fn process(&mut self, input: f32, ctx: &AudioContext) -> f32 {\n");
        code.push_str("        self.graph.process(input, ctx)\n");
        code.push_str("    }\n\n");

        // reset()
        code.push_str("    fn reset(&mut self) {\n");
        code.push_str("        self.graph.reset();\n");
        code.push_str("    }\n");

        code.push_str("}\n");
        code
    }
}

/// Generates optimized code from an [`AudioGraph`].
///
/// This is a convenience function that wraps [`GraphCodegen`].
///
/// # Example
///
/// ```ignore
/// let code = generate_graph_code(&graph, "MyEffect");
/// std::fs::write("generated.rs", code).unwrap();
/// ```
pub fn generate_graph_code(graph: &AudioGraph, struct_name: &str) -> String {
    GraphCodegen::new(graph, struct_name).generate()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_codegen() {
        let graph = AudioGraph::new();
        let code = generate_graph_code(&graph, "TestEffect");

        assert!(code.contains("pub struct TestEffect"));
        assert!(code.contains("impl AudioNode for TestEffect"));
        assert!(code.contains("fn process"));
    }
}
